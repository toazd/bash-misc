#!/bin/bash
# do not use, saved for reference
exit
# vim:set ft=shell
#
###############
## Reference ##
###############
#
# https://stackoverflow.com/questions/23367857/accurate-calculation-of-cpu-usage-given-in-percentage-in-linux
#
# https://man7.org/linux/man-pages/man5/proc.5.html
#
# https://www.kernel.org/doc/Documentation/filesystems/proc.txt
#
######################
## Pseudo-algorithm ##
######################
#
# PrevIdle = previdle + previowait
# Idle = idle + iowait
#
# PrevNonIdle = prevuser + prevnice + prevsystem + previrq + prevsoftirq + prevsteal
# NonIdle = user + nice + system + irq + softirq + steal
#
# PrevTotal = PrevIdle + PrevNonIdle
# Total = Idle + NonIdle
#
# totald = Total - PrevTotal
# idled = Idle - PrevIdle
#
# CPU_Percentage = (totald - idled)/totald

#sHZ=$(getconf CLK_TCK)

set -huo pipefail
shopt -s extglob

ParseProcStat() {

    # cpu - aggregate of all cpuN
    local bash_only=1 # [ 0 = use bc and printf ] | [ 1 = use only bash for arithmatic]
    local num_samples=1 # How many samples to output
    local sleep_interval_seconds="0.5" # total run time = ( num_samples * sleep_interval_seconds) + sleep_interval_seconds
    local idle=0
    local prev_idle=0
    local busy=0
    local total=0
    local prev_total=0
    local delta_total=0
    local delta_idle=0
    local usage_percent=0
    local label
    local f{0..9}=0
    local extra
    # cpuN - individual cores/threads
    # intr - interrupts serviced since boot time
    # ctx - context switches across all CPUs
    # btime - time the system booted (since Unix epoch)
    uptime_seconds=0
    # processes - processes and threads created
    # procs_running - threads running or read to run
    # procs_blocked - processes currently blocked/waiting for I/O to complete
    # softirq - softirqs serviced since boot time (The first column is the total of all softirqs serviced; each subsequent column is the total for that particular softirq)

    for (( i=0; i<=num_samples; i++ )); do
        while IFS=' ' read -r label f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 extra; do
            case $label in
                (cpu)
                    #    f0    f1      f2    f3      f4   f5       f6     f7     f8          f9
                    #  user  nice  system  idle  iowait  irq  softirq  steal  guest  guest_nice extra
                    idle=$(( f3 + f4 ))
                    busy=$(( f0 + f1 + f2 + f5 + f6 + f7 ))
                    total=$(( idle + busy ))

                    delta_total=$(( total - prev_total ))
                    delta_idle=$(( idle - prev_idle ))

                    # Skip the first iteration
                    (( i )) && {
                        if ((bash_only)); then
                            usage_percent=$(( ( delta_total - delta_idle ) * 100 / delta_total ))
                            if (( usage_percent < 1 )); then
                                echo "<1%"
                            else
                                echo "${usage_percent}%"
                            fi
                        else
                            usage_percent=$(bc -l <<< "scale=2; (($delta_total - $delta_idle) *100) / $delta_total")
                            usage_percent=$(printf '%3.1f' "$usage_percent")
                            echo "${usage_percent/%.0}%" # Remove trailing .0
                        fi
                    }

                    prev_idle=$idle
                    prev_total=$total

                    sleep "$sleep_interval_seconds"s
                ;;
                (*);;
                (cpu@([0-9]|[0-9][0-9]))
                    #    f0    f1      f2    f3      f4   f5       f6     f7     f8          f9
                    #  user  nice  system  idle  iowait  irq  softirq  steal  guest  guest_nice extra
                    :
                ;;
                (intr);;
                (ctxt);;
                (btime)
                    uptime_seconds=$(( $(date +%s) - f0 ))
                    # TODO output minutes, hours, day, etc. if any would be > 0
                    echo "Uptime (s): $uptime_seconds"
                ;;
                (processes);;
                (procs_running);;
                (procs_blocked);;
                (softirq);;
            esac
        done < "/proc/stat"
    done
}

ParseProcStat

