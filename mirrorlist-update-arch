#!/usr/bin/env bash

(( $(id -u) != 0 )) && echo "Root required" && exit 1

CleanUp() {
    rm -f "$tmp_file" "$tmp_valid_hosts" 2>/dev/null 1>&2
}

trap 'CleanUp' EXIT

! command -v curl 2>/dev/null 1>&2 && echo "curl required" && exit 1

mirrorlist_url='https://www.archlinux.org/mirrorlist/?country=all&protocol=https&ip_version=4&use_mirror_status=on'
connect_timeout=3
max_time=5
tmp_file=/tmp/"$(basename "$0")"-"$(date '+%s')".tmp
tmp_valid_hosts=/tmp/"$(basename "$0")"-valid_hosts-"$(date '+%s')".tmp
flag_header_found=0
count_lines=0
valid_hosts=0
failed_hosts=0
response=()

echo "Validating each host, please wait..."
while IFS= read -r
do
    count_lines=$((count_lines + 1))
    
    # "Header" used to validate input lines
    [[ $REPLY == '## Arch Linux repository mirrorlist'* || $REPLY == '## Filtered by'* || $REPLY == '## Generated on'* ]] && {
        flag_header_found=$((flag_header_found + 1))
        if [[ $REPLY == '## Generated on'* ]]
        then
            printf '%s %s %s\n' "$REPLY" "at $(date '+%T')" "by $(basename "$0") using"
            printf '%s\n' "## $mirrorlist_url" # NOTE: this adds a 4th line to the "header"
        else
            echo "$REPLY"
        fi
    }
    
    # Ignore these servers
    [[ $REPLY == *'zxcvfdsa.com'* ]] && {
        failed_hosts=$((failed_hosts + 1))
        continue
    }

    [[ $REPLY == '#Server'* && $flag_header_found -ge 1 ]] && {
        
        # Un-comment the host line
        REPLY=${REPLY/#'#Server'/Server}
        
        # Get the hostname to query
        host_name=${REPLY#*://}
        host_name=${host_name%%/*}

        IFS=' ' response=( $(curl -s --connect-timeout "$connect_timeout" -m "$max_time" -w "%{time_total} %{http_code}" "https://${host_name}" -o /dev/null 2>/dev/null) )
        printf '%s responded %s in %ss\n' "$host_name" "${response[1]}" "${response[0]}" >&2
        
        if (( response[1] >= 400 || ! response[1] ))
        then
            failed_hosts=$((failed_hosts + 1))
            echo "# $host_name returned http code ${response[1]} in ${response[0]}s"
            continue
        elif (( response[1] <= 400 ))
        then
            # Ignore hosts of which the round trip time is >650ms
            if (( $(bc <<< "${response[0]} > 0.650") ))
            then
                failed_hosts=$((failed_hosts + 1))
            else
                valid_hosts=$((valid_hosts + 1))
                echo "$REPLY # ${response[0]}s" >> "$tmp_valid_hosts"
            fi
        fi
    }
done < <(curl -sL "$mirrorlist_url" 2>/dev/null) > "$tmp_file"

# If at least one host is found and all three "headers" were found (validate the response)
if (( count_lines >= 5 && flag_header_found == 3 ))
then
    sort -n -k5 "$tmp_valid_hosts" -o "$tmp_valid_hosts"
    cut -d '#' -f 1 "$tmp_valid_hosts" >> "$tmp_file"
    
    echo "$valid_hosts valid hosts | $failed_hosts failed hosts"
    [[ -f /etc/pacman.d/mirrorlist ]] && {
        mv -v "/etc/pacman.d/mirrorlist" "/etc/pacman.d/mirrorlist~"
    }

    if mv -v "$tmp_file" "/etc/pacman.d/mirrorlist"
    then
        echo "Successfully updated mirrorlist"
    else
        echo "Failed to move $tmp_file to /etc/pacman.d/mirrorlist"
    fi
else
    echo "Not enough valid responses. No changes were made."
fi

